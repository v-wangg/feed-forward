const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const keys = require('../config/keys');
const mongoose = require('mongoose');

// Extract the user model class out of mongoose - this is equivalent to require()-ing the mongoose model we created in our models folder, except it avoids bugs in testing where a mongoose model file is require()-ed multiple times and thus multiple mongoose models are created, causing mongoose the throw an error
const User = mongoose.model('users');

/** Passport's serializeUser() function is called after done() inside the GoogleStrategy is called 
 *  Its purpose is to create a unique identifying token for us to put into the user's cookie for future requests
 *  The instance of the user model passed into the callback IS the instance of the user model we passed into       done() inside of the GoogleStrategy callback below
 *  The user's MongoDB record ID IS the unique identifying token we're giving passport (i.e the serialization      process was just us taking the user's id from the model instance) 
*/
passport.serializeUser((user, done) => {
    /** Since this process is very simple, we never expect any errors to occur, so we allways pass null as the      first argument into done
     *  The user.id passed as the second argument is NOT the user's googleID we saved into MongoDB
     *  user.id is a reference to the unique string automatically generated by MongoDB which identifies a          unique user record - the user separately has a user.googleID property as well
     *  We use this ID rather than the user's googleID because we CAN'T ASSUME that EVERY user will have a         googleID, since they may have signed up using Facebook, email, etc. - but we know all users have a         MongoDB record ID
     *  Right now, we no longer care about their googleID or any other ID - this was only used to identify a       user upon signin - from now on, we only care about this MongoDB record ID when dealing with a user
    */
    done(null, user.id);
});

// Passport's deserializeUser() function takes a user's unique ID and turns it back into a model instance - this makes sense since before, to serialize a user, we took a model instance and turned it into a unique ID
passport.deserializeUser((id, done) => {
    // The findById() function takes the MongoDB record ID we want to find as an arg and returns a promise         whose callback takes the user model instance found as a parmaeter - we just need to call done with it
    User.findById(id).then((user) => {
        done(null, user);
    })
});

/** Passport strategy which enables Google OAuth2.0

It takes our clientID and clientSecret (which we got from our google developers console and makes a request to Google's API telling Google to display a Google login page for the user

Once the user logs in, Google will display a permissions page asking the user for permission for our app to access certain data in their account (specified in the 'scope' property in auth-routes.js)

When the user gives us permission, the given callbackURL is called with a query string attached; this query string is an authorisation code from Google, and they expect us (passport) to take this code and send it back to them to confirm that it we indeed do have permission to access this user's data

Once Google confirms that we really do have permission to access this user's data through the auth code,they will reply with the user's information which we requested

The user's information is provided through the "verify callback" inside the second argument of this passport GoogleStrategy below

The access token is used to access and mutate a user's data, and the refresh token is used to refresh the access token, since it expires after some time

The profile contains all the user's information, and done() is called with the user as an argument to it in order to complete authorisation */

passport.use(
    new GoogleStrategy({
        clientID: keys.googleClientID,
        clientSecret: keys.googleClientSecret,
        /**
         * Below we have set a different googleRedirectURI for development (localhost...) and for production      (agile-plains.herokuapp...); usually we could just set callbackURL as a relative path and allow the    GoogleStrategy to append the correct absolute path automatically, but there's a problem with the way   Passport interacts with Heroku
         * The problem is that the GoogleStrategy assumes that IF an incoming request to begin the OAuth          process has come through a proxy, then it must not be a very secure request; this causes it to         append 'http' rather than 'https' onto our production callback URI from Heroku - but it gets it        right during development because we're making the request from locahost which has no proxy obviously
         * Now Heroku has a proxy for all incoming requests which helps it determine which one of ITS servers     our app is running on so that it can redirect any request from the browser to a heroku app to the      right app
         * So naturally, if we just keep it as a relative path URI, Google will throw an error saying 'redirect   URI mismatch', since in our Google Developers Console we specified https for our Heroku production     callback URI while passport asks Google to redirect us to an http URI
         * To fix this, we have set the correct and separate callback URIs as keys inside prod.js and dev.js      and have given the callbackURL property here an absolute path with a template string
         * We could have also just given another config property into the GoogleStrategy of 'proxy = true' 
            * But this causes the GoogleStrategy to trust ALL incoming requests which have gone through proxies   as secure and in turn attach https onto the URI
            * I'm not sure if this is good security practice or not, since Stephen Grider says he's doing it      for simplicity's sake, so I've gone with the safer option
         */
        callbackURL: `${keys.googleRedirectURI}/auth/google/callback`
    }, (accessToken, refreshToken, profile, done) => {
        /** 
         *  Check if current user exists; the .findOne() DB query function takes an object as a parameter whose    property is what we're looking for inside our User collection (i.e we specify the criteria we're       looking for)
         *  Since all database interactions are asynchronous, .findOne() returns a promise which we must handle
         *  The promise is resolved with a callback taking the user found; if none is found, it will be null
         */
        User.findOne({googleID: profile.id})
            .then((existingUser) => {
                if (existingUser) {
                    // done() is called with an error as the first arg and the new or existing user as the         second arg; it's defined this way since the GoogleStrategy was created so that we could     log a record of one of our users into our app - so once we've done that, we should have     reference to that user somehow
                    done(null, existingUser);
                } else {
                    /** Create a new instance of user and save it as a record into MongoDB
                     *  This is necessary because we need some sort of unique identifying token to compare for     consistency between logins for a given user; since a user's email can change, it's best    to save their googleID 
                     *  Since this action is asynchronous, it returns a promise which we must handle; .then()'s    callback is called with an instance of the saved user into the database
                     *  The new model instace we created with the 'new' keyword is SEPARTE to the savedUser        model instance given to us in the .then() callback
                        *   They both reference the SAME record in our MongoDB, except the 'new' keyword            instance is just a bit older, whereas the savedUser instance might have some data       in it which has been updated or changed upon saving the 
                        *   So, by convention, we always make use of the newer, more well maintained instance       of our MongoDB record, savedUser 
                     *  BUT this googleID is only needed to confirm signins - after a user has signed in, there    is NO NEED for their googleID at all, we will use their MongoDB record ID instead
                     */         
                    new User({ googleID: profile.id })
                        .save()
                        .then((savedUser) => {
                            done(null, savedUser);
                        })
                }
            })
    })
);